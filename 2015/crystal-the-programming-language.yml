---
title: Crystal: The programming language
speaker: Luís Ferreira
---

Okay, so our next speaker coming up is Luis Ferreira. We first met in Braga in the north of Portugal about a year ago for the first Ruby Con in Portugal. It's coming up when?  Fourteen and 15 of September. It's a great conference, I'd encourage everyone to attend. If you're from a company you should sponsor it. It was a first time conference but it really ran incredibly smoothly. And Luis is one of the organizers of that, and we got to know each other there. And he's here to talk about Crystal which is a topic that interests me a lot. A new programming language with that is sort of friendly for Rubyists. And he'll tell you more about it. Hopefully as soon as he finishes setting up.


Ready to go ?
yep, I think so.


Luis, round of applause for Lis.


Thanks. (Applause)


Of


So, hi everyone, hope you're having a good time, ‑‑ we're here to talk a bit about Crystal, it's a pretty new language, but it's also fun. Before we get into Crystal a bit more about me, really fast, this is my, my handle@zamith. This is a company I work for called sub visual in Braga, they were kind enough to get me here, thanks to them, Rubyconf Portugal is happening in a month. We're having a pretty good line up ‑‑ PJ that spoke yesterday is going to be the MC, so the venue is fabulous, you should definitely think about going. Also we're having a raffle, sometime today it should be announced. And we are giving away a free ticket for someone here so please be excited about that. Now, Crystal. What is Crystal ‑‑


Don't touch it.


Okay.


So Crystal an efficient Ruby‑like language. Really fast, syntax similar to Ruby, you'll see more about it in a while. One of the different things about Crystal is that it is compiled and it is more strongly typed than Ruby, it also has static checks which brings some more safety than Ruby does. It also has very simple C bindings which is nice for a lot of reasons that we might discuss in a while as well. Another very cool thing about Crystal is that it's a hundred percent self hosted, that means that it's all Crystal is Crystal, so if you understand the syntax, which is, again, should be familiar if you know Ruby, it's very easy to just dig into the parser, lexer into the core of the language and just contribute. Which is also very nice. As I said, Crystal is a type language. But it does have a very good type infer remembers. So you kind of all the time it feels like you're writing Ruby and not worrying too much about types, if you don't want to. But you'll probably will want to if you start writing type code. But that means that you can set your availables just as you would in Ruby. You have a number that's 42, so it's an integer or a fixed number that would be the equivalent in Ruby, in Crystal it's called Int 32, it works just as you would expect to in Ruby. You can do the same thing with arrays. You have an array of number, you can append to it, same syntax as Ruby. But, now the first small difference between Crystal Andrew by if you check the class, it's not just array, it's an array of Int, so an array of integers. This is a bit different and this is going to be important in a while. So here if this was Ruby you would expect it to work, right . So you have an array, you append an array of integer, you append an integer and you append a string and you get a class, what could possibly go wrong. Well, in Crystal it does not work. This is the error it's going to give you at compile time so this happens the program will not even run. What it's telling you is that you cannot append a string to an array of integers. Okay. This is what this is telling you. In Crystal, the type of ‑‑ the type infer remembers system works when osseterring the variable. You set an array of integers you cannot then say oh, I want string as well that is not safe, Crystal will not let you do that. This is pretty easy to fix, one of the ways would be to create an array that has integers and a string then Crystal will know, okay, so you can see the type is not an array of Ints anymore, it's an array of strange things, which is union type which is very important in Crystal the array can either have strings or integers, okay, and you can have more types as well. Of course this is not always the best way of initializing the array. Want to have elements with all the types you need in the array, so you can also do this. Okay, you can say that's an ray of strings or Ints, and it will work just fine as well. Now that we know a bit more about how types work in Crystal and the most important part here, remember is the union type, okay, that's the most different thing. And ‑‑ but there's a lot that Crystal can do for you at compile time now. For instance let's look at this Ruby example. Very simple method called stripping size, it takes a string and brings the length of the string. If you try to call it in two different places, if you run this code you'll get 16, that's the length of that string. And then, Boom, okay, so you have an error, if you've be coding Ruby for a while you've probably seen similar errors, and this is the problem here is not the actual error, I think, the problem is that it happens in Runtime, okay. So you might only find out when you're already running ‑‑ already have deployed this code or if you have a very strong test suit you might catch it early, but you never really know. In Crystal if we take like the exact same code, it doesn't have the prints there, but you imagine it does. You get a very similar error saying that leg is not defined for Nil, we expect that. However this error happens at compile time, not Runtime, okay. So the program won't even run, it will tell you there's a Nil, an undefined method for Nil before it even runs, so that problem is solved. Let's take a look at a bit more complex example. Saming the same model from before, the array of strings and Ints, and let's go over what it's doing here. So we have an array of Ints.  ‑‑ sorry an array of strings or Ints and we append an Int and then a string. We take the array and we get the last ‑‑ of the array and then we ask for the size of that element. If you don't know it, size is only available for strings not for Ints. But this should work in Ruby, right, because the last element is a string, it has the size method, the typing and everything it should work. In Crystal it doesn't. Okay. We get undefined method size for Int, this is because Crystal makes sure that any method you call on an element of the array must be valid for all the types in the union type of array. So it's really safe that way. It cannot really make sure that you're not messing it up along the way, if you're doing something that can potentially introduce a bug, it will not let you run the program. C bindings. As I said, Crystal has a very good integration with C, this is because Crystal is compiles to LLVM byte code, so it's really easy to integrate with C, going to be very similar. But if you ever try to do it ‑‑ have tried to do it in Ruby you might have noticed that is not that easy, not very easy to get started any way. You probably will need to write some C and worse than that you need to learn like Ruby syntax or Ruby C implementation like the RB Ints and all that, basically it a ESARIS a bit of a pain.  I think Fiddle is something that's happening and looks nice.  I think we have a talk tomorrow.  I haven't given it a close look. But it looks better, I think. But in Crystal it's already very simple to integrate with C. Say you want to have the A to I function from the standard library. Standard C library. That's it, say you want to use L LibC and declare the header of the function and you can use it around the LibC name space. This is a bit cheating because LibC is already in the core, so you can just use it. Over, if we want like random C library we needed to use it would be a bit trickier like one line extra. You have to call that link on top, for instance if we need to red line it is an example of using the readline C library. You need to link it, declare header again, then we have a code using readline. This would prompt for a name, you can give it a name and it will print it as a string. The small like difference you have to note here is the string.new that's because if you also notice under the header we're say that the return value, that's what's coming after the colon there, so the pointer UInt, we get the pointer back, and we have to cast it to a string so we can use it as a regular string. Other than that it's very, very simple to use, and most of the core of Crystal actually uses this for a lot of reasons. Some ‑‑ some parts of the code they didn't have time to rewrite, so you can just leverage a lot of what the C community has done, which is a much bigger community than what Crystal is right now. Another important part of Crystal of are something called generics that we don't really have in Ruby. They are in other languages. The idea is let's take this Ruby Code this is a Foo class, very simple class, you have an Attr reader with value and an initializer that takes value. Very simple class. We create anen stance of the class with an integer and we get the absolute value for that integer. We get one. Fine. Then we create another instance with a shard and we get the ASCII code for that. Fine, it works well, no problem there, everything in Ruby just works. However, if you try the same exact thing in Crystal, minus the slight differences in the syntax, which we don't have the at reader, it's called better, you have the setter and property for the access sore, but it's very similar, and we have the coffee scripts like like, initializer, we don't have to set the value and like repeat yourself three times, you can just do it once. But then if we try the same exact code freeuate a Foo for Int and a Foo for shard, and create different methods and instances it won't work, we get a similar error, we have an undefined method Absf Char. This is because how it works in Crystal. Crystal needs to find a type for that value, you're not saying what the type of the value is, the way Crystal does it is it goes through every place where you initialize this class and it sees the type, so here's an integer here's a Char, what's the type of value, it's a union of Ints and Chars this won't work because it's not available for Char this is a Compiler report so it won't even run. You can fix it easily by having something called generic, you can simpler this is a Foo of T, like a generic type, you say that T is going to be defined by the type of the value. What this is telling Crystal each instance of Foo can have a different type, a type T that is defined when we initialize it and defined by the value. This instance of Foo will be a Foo of Int and this instance of Foo will be of Chars. And then it will just work again like it works in Ruby. So this is how arrays are implemented. This is how hashes are implemented, so each instance of an array can have it's own type, it can be a union type, we saw arrays that had integers and strings. So those are arrays of union types. However we do not have an array with all the types that we ‑‑ using all rays that would be a mess. Another of difference between Crystal Andrew by that I find really interesting, is that you have method overloading. If you're not familiar with method overloading paceically it says ‑‑ it means that you can define the same method over and over again but with a different number of our arguments, so the RT, ‑‑ if you have a different number of arguments the different methods, if you have different types even with same number of arguments it's a different method and what in Crystal we called that the yieldness of a method, so if a method yields to a block, then it's different even though it might have the same number of arguments and the same types if it yields and another method doesn't, they're different. What this means is that you can do something like this, okay, so of course this is the bias towards Crystal, you can see the same thing written in Ruby and Crystal. You have sum method that can take different number of arguments, it can take different types of arguments, you can pass it in strings or integers, it will just work, in Crystal it's just easy, one line per method and you do everything under the header of the method definition. In Ruby you have to get everything and then do it inside of the method. This is, I think an interesting thing and would be nice to have in Ruby. Last part of my talk is starting and it's about shards, so what are shards?  Shards is the name we have for gems, if you build a library in Crystal, for now, at least, it's called shard. And how does dependency management work?  For now, and again Crystal is a very new language that's evolving a lot so the project, the dependency system is not great, yet, but the way it works right now is that you need to have a file calmed project file. Similar to the gem file, has it's own DSL, and then you see there you can get a library from GitHub. As long as the library is well built. The thing about Crystal, though, and then you can just use it, you can require it and use it. The thing about the dependency system as it is right now. And probably how it will be, it only works on GitHub and bit bucket and all that, but the idea is that it's a decentralized system, so there's no Ruby gems, there's no place where you have all the meta information.  I don't know if this is going to be like that forever, but right now it is. There's a lot of ‑‑ there's a side project called shards going on that's trying to build a better dependency management system. And ‑‑ which are hard, if you have tried to do one. And then so not really set in stone how this work but the idea of the creators of the language to make it decentralized. So you have a report on GitHub and bit bucket you just use it, there's no central place where everything is. This is all fun and nice, but it makes disCommonwealth of Virginiaability really hard you can use Ruby gems and search for a gem, you cannot do it in Crystal, there's no central place, you could search in GitHub, but that's more painful so there's a web site called Crystalshards. You can look at shards in different orders. You can see the ones that have more shards, the more popular shards, the ones more recently updated, you can see a lot of stuff here, and this works for now, at least, just because there are not that many. You can see like 180 shards, so that's not a lot. But it's growing, like many maybe two months or three months you go from 60 to 180, a community that's thriving right now, so very, very good time to come to the community and I like to stress that, there's a lot of opportunities if you like to contribute to Open Source or you want to start contributing to Open Source. There's a lot of stuff that is not done in Crystal. Von in the language, the core of the language you can contribute to that. There's a lot of stuff to do that, if you want to build libraries, to do stuff. For instance maybe six months there was no post Res so someone started building that there's my Msyyl. There's a lot of stuff.


Okay, I'm going do a really quick demo and try not to blow too many things. Is the font good enough?  Can you see it?  So I have here a sequence generator ‑‑ very simple recuresive one. It's very simple and written in Ruby. And it just, it's printing the element number of the sequence. It generates the sequence and gets the 40th element and it brings it. Very simple code. It should work just fine. If if we do it in Ruby. You have to wait a while .
not too much, hopefully. About ... sometime ... okay, it work, I forgot to put the time here, let's do it again. It should be about 8 seconds. Or it might be taking longer because I'm not plugged in. Okay, 9 seconds. So this is the Ruby implementation. Okay, and if you notice it's the 40th if you try to do 45th you might grab a share and wait because it's going to take a while. In Crystal we can try it. We can pass in, in this particular instance because it's such a simple program that the code is the exact same in Crystal you can just pass it in the Ruby file and it will just work. Okay, it took one second. However what we are doing here is that we're compiling the program and then running it. So we can compile it first. So you can do Crystal build, that will compile your file and you also have a release flag that makes it even faster. So we compile it and then we can time it. Boom, 0.2 seconds. And it does the same thing like generates ‑‑ it's here, and took the same code. So it's very, very fast. Especially for CPU bound programs, you can almost write Ruby and make it like super fast. So please try some Crystal. And hopefully you can get ‑‑ we can get some of you to the community. That would be great. Another thing that I can mention that is super fast in Crystal is Json parson, if you have a lot of that, Crystal is super, super fast doing that. It has some small DSL that lets you define the structure of your Json, so it's a very good use case to start using Crystal if you have that problem. Okay, that's it. Thank you. (Applause)


So, I'll be doing the question moderation. There's someone standing, great


Luis. Thank you, personally I had the impression that the type system looked like the one used by the ML language. Where does Crystal draw it's inspiration for the type?


Do I have to repeat the question?  So where does the type language or the type system come from in Crystal?  To be honest, I'm in the really sure. It takes a lot of inspiration from a lot of languages, I know it takes inspiration from Ruby from if you have if I script, some inspiration, from Elixer some inspiration maybe from there it got a bit of the type system. The creators of languages are going around to conferences and talking to people about new ways to do languages. It also a thing I didn't mention Crystal has a macro system so it can ‑‑ ‑‑ you can do some fancy stuff at compile time and it takes that from some other languages. Obviously it's a new language it takes a lot from other languages, I don't know for sure what comes from which language.


Any other questions?


One in the back there?


Come here I'll meet you halfway.


Thanks just a short question. Looks really great. Do you have a community code of conduct for your developers. And do you have a core team and what's the gender distribution.


Sorry I didn't understand the question, sorry could you repeat?


Do you have a community code of conduct and do you have a core team and how does the gender distribution. Thanks.



I'm not on the core team, but I do help.  I don't think there's a code of conduct, actually, if there is it's pretty recent. As far as distribution goes, it's pretty bad. As far as diversity, it's pretty bad. It's mostly ‑‑ can you hear me, it's mostly guys. So, but please, join we'll ‑‑ I think if we want more diversity for sure. So if you ‑‑ there's a lot of women here, so, please join. The community is very ‑‑ is very friendly, I think to everyone and very welcomingsh it's just a small community and just happened to be that way.  I don't think there's any bias towards any gender in particular.


It's a very young language and there needs to be a lot of work, and this is one of them.


You mentioned it's a young language, do the creators consider it production ready?


Sorry.


Is it considered production ready?


Oh, production ready. That's a good question, so it's not 1.0 yet, so it's not a hundred percent stable, but I think it is ready, like for small things like I was saying if you want to parse Json, you have like a Microservices that parses Json, ready for that, to build a whole App in Crystal, probably not a good idea yet. Also because we don't have a lot of frame ‑‑ you have some frameworks now that are starting to be built, but very early stage. Everything is very early stage. To do smalls and to do a small subset of things, awesome. Actually like Crystal shards is built on Crystal hand has been running for a couple of months, so it does work. But I wouldn't advise to build your business on top of it yet. Please don't do that yet.


Good point. One more question.


Are there some known limitations in meta‑programming, things where you can say from the beginning this will never work in Crystal compared to Ruby just because of its concept?


There's like Eval, stuff like that. Some of them, it's in the all, some of the meta‑programming you can do in Ruby because Crystal needs to ‑‑ can only take information that you have at compile time. Anything you need Runtime informs to be able to do it won't work. Like for instance there is a method missing in Crystal but it is limited compared to the Ruby mechanism, you cannot do everything that Ruby memberrism does, so meta‑programming is not as powerful as Ruby is.  I think that's the main thing.


Thank you, Luis (Applause)
